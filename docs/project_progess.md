**This file contains documentation about the project progress made so far.**

## The challenge
This project was conducted as a part of the course *Cyber-crime and Computer Forensics* at EURECOM in the spring of 2025. The following instructions were given:

```
Write a python library to inspect NSIS installers.
You can find several resources online, such as 
       https://nsis.sourceforge.io/can_I_decompile_an_existing_installer
       https://sourcforge.net/projects/nsidis/  (it is from 2015, does it work?)
       https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/
Check what is available, try to make it work and package everything in a 
container or easy-to-use python library.
```

The main challenge was that given a Windows installer generated by NSIS, retrieve all files associated with the installer and more specifically the NSIS script used to generate the installer. Retrieving the NSIS script would be helpful in order to understand what libraries are dynamically loaded by the installer during runtime and from this make a verdict whether an installer is malicious or not. 

## Using 7-zip
7-zip was capable of decompressing NSIS installers in past versions from 4.42. It was also capable of extracting the compiled scriptcode since version 9.34. However, this functionality was later removed in version 15.06 and have not been supported ever since ([source](https://nsis.sourceforge.io/Can_I_decompile_an_existing_installer%3F)). Using the version from 2015 might be a straight road forward in order to retrieve the NSIS script, but the version contains well-documented vulnerabilities. I decided to not follow this path and would not recommend anyone to do so without utilizing a VM. 

## Path towards retrieving the DLLs 
The current library implementation is capable of retrieving information about the DLLs by calling the function 'resolve_pe_imports' inspired by the following [article](https://vtopan.wordpress.com/2019/04/12/patching-resolving-imports-in-a-pe-file-python-pefile/ ). The function parses information contained in the PE directory entry *IMAGE_DIRECTORY_ENTRY_IMPORT*. This entry contains information related to the Import Address Table (IAT) and contains information about DLLs and functions imported by the installer. So far, this information is pretty uninteresting, as most of the DLLs are valid and used frequenctly in any Windows application (malicious or not). Still, it demonstrates how we can use the pefile library to understand how the NSIS generated installers behave differently depending on what instructions are defined in the script. The next step would therefore be to retrieve the .nsi script used to create the installer. With access to the full script, we would not only be able to identify static imports, but also custom DLLs loaded during runtime.

## Path towards retrieving the NSIS script
According to my understanding, the author of a NSIS script can choose to not include any trace of the script in the final installer (see section [About](https://nsis.sourceforge.io/Can_I_decompile_an_existing_installer%3F)). To investigate this hypothesis further, a way to move forward is to create two installers generated using NSIS. These two installers should be generated using identical scripts except from the part where one explicitly states to includ the NSIS script while the other one does not. 

This have been done by writing two identical .nsi scripts (using the same compression method), see [test scripts](tests\nsis_scripts). In `with.script.nsi`, the following instruction was included:

``` 
# Embed the script itself in the installer (script name - "with_script.nsi")
    File /oname=benign_script.nsi "with_script.nsi"  
```

The brute-force approach from here would be to reverse-engineer the byte code of the two scripts to understand where the NSIS-script is located in the installer. This can be achieved by first locating the NSIS "magic number" reference in the byte code and from there reverse-engineer the byte sequence. 

However, this proved to be unfeasible in practice. The two headers of the generated .exe installers changed completely and my conclusion was that it would not be possible to reverse-engineer byte by byte, since they differed too much from one another and common patterns were not easy to detect. I've kept the method `_read_byte_sequence(compressed)` as reference in the library. 

Instead, I tried to first detect if the .nsi script had been embedded as plaintext in the installer. As expected, this was not the case. However, one notable difference between the two installers was that the one with the embedded .nsi script calls functions from `ole32.dll`, while the other one does not. This is an indication that the script uses COM (Component Object Mode)to embedd the script data. For further progress, it would be interesting to investigate this lead further. 

I realized that by explicitly including the .nsi script in the final installer, the current version of 7-Zip was able to extract it in its entirety. However, this scenario is unlikely in real-world malware, as no malware author would deliberately include the script in such an accessible form. I was back on square one and was at this point running out of time to continue working on the project. 

## Suggestions for further development
If I were to continue working on this project, I would focus on the following areas to progress further:

1.  Investigate the three different compression methods used in NSIS: ZLIB (default), BZIP2 and LZMA, starting with ZLIB. 
- Create a method that given a byte sequence of an installer can reverse-engineer and acquire a decompressed version of the data.
- This would allow me to extract embedded files and possibly the script without relying solely on 7-Zip.
2. I noticed that installers embedding the NSIS script invoke `ole32.dll` (COM interface), suggesting that the script could be embedded or handled through COM objects. To investigate this further:
- Analyze how NSIS uses COM to embed or access the script
- Research how authors might conceal or dynamically load scripts using COM.
3. Generate additional NSIS installers for testing purposes.
- With more test cases it would be easier to identify recurring patterns in raw byte sequences. 
- If a pattern is identified, create new methods to automatically identify relevant data blocks. 

## Resources

I've done a lot of research to understand the problem and find solutions. Here are some of the resources I've accessed the most frequently throughout the project:

**Articles**
- https://nsis.sourceforge.io/Can_I_decompile_an_existing_installer%3F
- https://nsis.sourceforge.io/Docs/Chapter4.html#instattribs
- https://yoroi.company/research/yes-cyber-adversaries-are-still-using-formbook-in-2021/
- https://www.threatdown.com/blog/revisiting-the-nsis-based-crypter/
- https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/
- https://research.checkpoint.com/2024/static-unpacking-for-the-widespread-nsis-based-malicious-packer-family/
- https://medium.com/@0xwan/how-to-reverse-engineer-executable-files-230216bdca3b
- https://hshrzd.wordpress.com/2016/07/03/unpacking-nsis-based-crypter-step-by-step/
- https://tech-zealots.com/malware-analysis/pe-portable-executable-structure-malware-analysis-part-2/

**Source code**
- https://github.com/isra17/nrs/blob/master/nrs/nsisfile.py
- https://github.com/Noice2k/NsisDecompiler/blob/master/NsisFile.cpp
- https://github.com/M2Team/NanaZip/tree/main
- https://github.com/myfreeer/7z-build-nsis
- https://files.planet-dl.org/?dir=cw2k/Nullsoft%20Installer%20Decompiler
- https://sourceforge.net/p/sevenzip/wiki/Home/
